<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Universe 1867: Wolfram ↔ Lean Bridge</title>
  <style>
    :root {
      --bg: #000000;
      --card: #0a0a0a;
      --border: rgba(255,255,255,0.1);
      --text: #fafafa;
      --dim: #9ca3af;
      --accent: #60a5fa;
      --wolfram: #dd4a22;
      --lean: #3b82f6;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      min-height: 100vh;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 8px;
      font-size: 24px;
    }
    h1 .wolfram { color: var(--wolfram); }
    h1 .lean { color: var(--lean); }
    h1 .arrow { color: var(--dim); margin: 0 8px; }
    .subtitle {
      text-align: center;
      color: var(--dim);
      font-size: 12px;
      margin-bottom: 24px;
    }
    .subtitle a { color: var(--accent); }

    .stats-bar {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 24px;
      padding: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    .stat { text-align: center; }
    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
    }
    .stat-label {
      font-size: 11px;
      color: var(--dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 24px 0 16px 0;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .section-header.wolfram { border-color: var(--wolfram); }
    .section-header.lean { border-color: var(--lean); }
    .section-header h2 { font-size: 18px; font-weight: 600; }
    .section-header .tag {
      font-size: 10px;
      padding: 3px 10px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .section-header.wolfram .tag { background: rgba(221,74,34,0.2); color: var(--wolfram); }
    .section-header.lean .tag { background: rgba(59,130,246,0.2); color: var(--lean); }

    .viz-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .panel-header {
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      font-size: 13px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    .panel-content {
      padding: 12px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .panel-content img {
      width: 100%;
      border-radius: 4px;
      flex: 1;
      object-fit: contain;
    }
    .panel-content.no-padding {
      padding: 0;
    }

    .code-block {
      background: #111;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 10px;
      line-height: 1.5;
      overflow-x: auto;
      white-space: pre;
    }
    .code-block .comment { color: #6b7280; }
    .code-block .keyword { color: #c084fc; }
    .code-block .type { color: #34d399; }
    .code-block .number { color: #60a5fa; }

    .rule-display {
      background: rgba(221, 74, 34, 0.1);
      border: 1px solid rgba(221, 74, 34, 0.3);
      border-radius: 6px;
      padding: 12px;
      text-align: center;
      margin-bottom: 12px;
    }
    .rule-display .rule {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--wolfram);
    }
    .rule-display .label {
      font-size: 10px;
      color: var(--dim);
      margin-top: 4px;
    }

    /* 3D Viewer - fills container */
    .viewer-3d {
      width: 100%;
      height: 100%;
      min-height: 400px;
      border-radius: 4px;
      position: relative;
      background: #050505;
    }
    .viewer-3d canvas {
      width: 100% !important;
      height: 100% !important;
      border-radius: 4px;
    }
    .viewer-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 6px;
      z-index: 10;
    }
    .viewer-controls button {
      padding: 6px 10px;
      background: rgba(0,0,0,0.7);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
    }
    .viewer-controls button:hover { background: rgba(96,165,250,0.3); }
    .viewer-controls button.active { background: rgba(96,165,250,0.5); }

    .evolution-strip {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }
    .evolution-strip h3 {
      font-size: 14px;
      margin-bottom: 12px;
      color: var(--wolfram);
    }
    .frames {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 8px;
    }
    .frame {
      flex-shrink: 0;
      width: 100px;
      text-align: center;
    }
    .frame img {
      width: 100%;
      border-radius: 4px;
      border: 1px solid var(--border);
    }
    .frame-label {
      font-size: 10px;
      color: var(--dim);
      margin-top: 4px;
    }

    .theorem-box {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 6px;
      padding: 12px;
      margin-top: 12px;
    }
    .theorem-box h4 {
      font-size: 12px;
      color: var(--lean);
      margin-bottom: 8px;
    }

    .back-link {
      display: inline-block;
      color: var(--dim);
      font-size: 12px;
      text-decoration: none;
      margin-bottom: 16px;
    }
    .back-link:hover { color: var(--accent); }

    .bridge-info {
      text-align: center;
      margin-top: 24px;
      padding: 16px;
      border-top: 1px solid var(--border);
    }
    .bridge-info p { font-size: 11px; color: var(--dim); }
    .bridge-info code { background: #111; padding: 2px 6px; border-radius: 3px; }

    /* Make panels equal height */
    .viz-grid-equal {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
      align-items: stretch;
    }
    .viz-grid-equal .panel {
      min-height: 450px;
    }

    /* 2D Canvas for proof graph */
    .canvas-2d {
      width: 100%;
      height: 100%;
      min-height: 380px;
      background: #050510;
      border-radius: 4px;
    }

    /* Semantics section */
    .semantics-section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }
    .semantics-section h3 {
      font-size: 14px;
      margin-bottom: 12px;
      color: var(--lean);
    }
    .semantics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 800px) {
      .semantics-grid { grid-template-columns: 1fr; }
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">← Back to Visualizations</a>

  <h1>
    <span class="wolfram">Wolfram Physics</span>
    <span class="arrow">↔</span>
    <span class="lean">Lean 4</span>
  </h1>
  <p class="subtitle">
    Universe 1867 from the <a href="https://www.wolframphysics.org/universes/wm1867/" target="_blank">Registry of Notable Universes</a>
  </p>

  <div class="stats-bar">
    <div class="stat"><div class="stat-value">7</div><div class="stat-label">Generations</div></div>
    <div class="stat"><div class="stat-value">74</div><div class="stat-label">Events</div></div>
    <div class="stat"><div class="stat-value">150</div><div class="stat-label">Final Edges</div></div>
    <div class="stat"><div class="stat-value">75</div><div class="stat-label">Vertices</div></div>
  </div>

  <!-- WOLFRAM SECTION -->
  <div class="section-header wolfram">
    <h2 style="color: var(--wolfram);">Wolfram Physics Hypergraph</h2>
    <span class="tag">Source Model</span>
  </div>

  <div class="rule-display">
    <div class="rule">{{{1,2},{2,3}} → {{2,3},{2,3},{3,4},{1,3}}}</div>
    <div class="label">Universe 1867 Rewriting Rule · Initial: {{1,1},{1,1}}</div>
  </div>

  <div class="viz-grid-equal">
    <div class="panel">
      <div class="panel-header">2D Graph View</div>
      <div class="panel-content">
        <img src="universe1867_graph.png" alt="Universe 1867 2D Graph">
      </div>
    </div>
    <div class="panel">
      <div class="panel-header">
        Interactive 3D View
        <span style="font-size:10px;color:var(--dim);">drag to rotate</span>
      </div>
      <div class="panel-content no-padding">
        <div class="viewer-3d" id="wolfram3d">
          <div class="viewer-controls">
            <button onclick="resetWolfram3D()">Reset</button>
            <button id="spinWolframBtn" class="active" onclick="toggleWolframSpin()">Spin</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="evolution-strip">
    <h3>Evolution: 7 Generations (74 Events)</h3>
    <div class="frames">
      <div class="frame"><img src="frame_0.png" alt="Gen 0"><div class="frame-label">Gen 0: 2 edges</div></div>
      <div class="frame"><img src="frame_1.png" alt="Gen 1"><div class="frame-label">Gen 1: 4</div></div>
      <div class="frame"><img src="frame_2.png" alt="Gen 2"><div class="frame-label">Gen 2: 8</div></div>
      <div class="frame"><img src="frame_3.png" alt="Gen 3"><div class="frame-label">Gen 3: 14</div></div>
      <div class="frame"><img src="frame_4.png" alt="Gen 4"><div class="frame-label">Gen 4: 26</div></div>
      <div class="frame"><img src="frame_5.png" alt="Gen 5"><div class="frame-label">Gen 5: 44</div></div>
      <div class="frame"><img src="frame_6.png" alt="Gen 6"><div class="frame-label">Gen 6: 80</div></div>
      <div class="frame"><img src="frame_7.png" alt="Gen 7"><div class="frame-label">Gen 7: 150</div></div>
    </div>
  </div>

  <!-- LEAN SECTION -->
  <div class="section-header lean">
    <h2 style="color: var(--lean);">Lean 4 Proof Dependency Graph</h2>
    <span class="tag">Verified Formalization</span>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:#34d399;"></div> Structure</div>
    <div class="legend-item"><div class="legend-dot" style="background:#60a5fa;"></div> Definition</div>
    <div class="legend-item"><div class="legend-dot" style="background:#c084fc;"></div> Theorem</div>
    <div class="legend-item"><div class="legend-dot" style="background:#fbbf24;"></div> Root</div>
  </div>

  <div class="viz-grid-equal">
    <div class="panel">
      <div class="panel-header">2D Proof Structure</div>
      <div class="panel-content no-padding">
        <canvas class="canvas-2d" id="lean2d"></canvas>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header">
        Interactive 3D Proof Structure
        <span style="font-size:10px;color:var(--dim);">drag to rotate</span>
      </div>
      <div class="panel-content no-padding">
        <div class="viewer-3d" id="lean3d">
          <div class="viewer-controls">
            <button onclick="resetLean3D()">Reset</button>
            <button id="spinLeanBtn" class="active" onclick="toggleLeanSpin()">Spin</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- SEMANTICS SECTION (moved to bottom) -->
  <div class="semantics-section">
    <h3>Parallel Rewriting Semantics (Lean 4 Implementation)</h3>
    <div class="semantics-grid">
      <div>
        <div class="code-block"><span class="comment">-- WolframModel parallel semantics in Lean 4</span>
<span class="keyword">structure</span> <span class="type">Hyperedge</span> <span class="keyword">where</span>
  src : <span class="type">Nat</span>
  tgt : <span class="type">Nat</span>

<span class="keyword">abbrev</span> <span class="type">Hypergraph</span> := <span class="type">List Hyperedge</span>

<span class="keyword">def</span> findAllMatches (g : <span class="type">Hypergraph</span>) : <span class="type">List Match</span> := ...
<span class="keyword">def</span> selectNonOverlapping (m : <span class="type">List Match</span>) : <span class="type">List Match</span> := ...

<span class="keyword">def</span> applyRule (e1 e2 : <span class="type">Hyperedge</span>) (fresh : <span class="type">Nat</span>) :
    <span class="type">List Hyperedge</span> :=
  <span class="keyword">let</span> a := e1.src; <span class="keyword">let</span> b := e1.tgt; <span class="keyword">let</span> c := e2.tgt
  [⟨b,c⟩, ⟨b,c⟩, ⟨c,fresh⟩, ⟨a,c⟩]

<span class="keyword">def</span> stepGeneration (g : <span class="type">Hypergraph</span>) : <span class="type">Hypergraph × Nat</span> := ...
<span class="keyword">def</span> evolveGenerations (g : <span class="type">Hypergraph</span>) (n : <span class="type">Nat</span>) : ...</div>
      </div>
      <div>
        <div class="theorem-box">
          <h4>Verified Theorems (Computable Proofs)</h4>
          <div class="code-block"><span class="keyword">theorem</span> initial_edge_count :
    edgeCount initial = <span class="number">2</span> := <span class="keyword">rfl</span>

<span class="keyword">theorem</span> rule_produces_four_edges :
    (applyRule e1 e2 fresh).length = <span class="number">4</span> := <span class="keyword">rfl</span>

<span class="keyword">theorem</span> self_loops_match :
    (findAllMatches initial).length > <span class="number">0</span> := <span class="keyword">by</span> native_decide

<span class="comment">-- #eval universe1867_gen7</span>
<span class="comment">-- Result: (150 edges, 74 events, 75 vertices) ✓</span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="bridge-info">
    <p>
      Source: <a href="https://www.wolframphysics.org/universes/wm1867/" style="color: var(--accent);">wolframphysics.org/universes/wm1867</a>
      · Lean: <code>HeytingLean.WolframPhysics.Universe1867</code>
    </p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Lean proof dependency graph structure
    const proofNodes = [
      // Structures (green)
      { id: 'Hyperedge', kind: 'structure', label: 'Hyperedge' },
      { id: 'Match', kind: 'structure', label: 'Match' },
      // Definitions (blue)
      { id: 'Hypergraph', kind: 'def', label: 'Hypergraph' },
      { id: 'universe1867_initial', kind: 'def', label: 'initial' },
      { id: 'maxVertex', kind: 'def', label: 'maxVertex' },
      { id: 'findAllMatches', kind: 'def', label: 'findAllMatches' },
      { id: 'applyRule', kind: 'def', label: 'applyRule' },
      { id: 'matchesOverlap', kind: 'def', label: 'matchesOverlap' },
      { id: 'selectNonOverlapping', kind: 'def', label: 'selectNonOverlapping' },
      { id: 'stepGeneration', kind: 'def', label: 'stepGeneration' },
      { id: 'evolveGenerations', kind: 'def', label: 'evolveGenerations' },
      { id: 'evolveStates', kind: 'def', label: 'evolveStates' },
      { id: 'universe1867_gen7', kind: 'def', label: 'gen7' },
      { id: 'edgeCount', kind: 'def', label: 'edgeCount' },
      { id: 'vertexCount', kind: 'def', label: 'vertexCount' },
      // Theorems (purple)
      { id: 'initial_edge_count', kind: 'theorem', label: 'initial_edge_count' },
      { id: 'initial_vertex_count', kind: 'theorem', label: 'initial_vertex_count' },
      { id: 'rule_produces_four_edges', kind: 'theorem', label: 'rule_produces_4' },
      { id: 'self_loops_match', kind: 'theorem', label: 'self_loops_match' },
    ];

    const proofEdges = [
      // Structure dependencies
      ['Hyperedge', 'Hypergraph'],
      ['Hyperedge', 'universe1867_initial'],
      ['Hyperedge', 'applyRule'],
      ['Match', 'findAllMatches'],
      ['Match', 'matchesOverlap'],
      // Definition dependencies
      ['Hypergraph', 'universe1867_initial'],
      ['Hypergraph', 'maxVertex'],
      ['Hypergraph', 'findAllMatches'],
      ['Hypergraph', 'stepGeneration'],
      ['Hypergraph', 'edgeCount'],
      ['Hypergraph', 'vertexCount'],
      ['findAllMatches', 'selectNonOverlapping'],
      ['matchesOverlap', 'selectNonOverlapping'],
      ['maxVertex', 'stepGeneration'],
      ['applyRule', 'stepGeneration'],
      ['selectNonOverlapping', 'stepGeneration'],
      ['stepGeneration', 'evolveGenerations'],
      ['stepGeneration', 'evolveStates'],
      ['evolveGenerations', 'universe1867_gen7'],
      ['universe1867_initial', 'universe1867_gen7'],
      // Theorem dependencies
      ['edgeCount', 'initial_edge_count'],
      ['universe1867_initial', 'initial_edge_count'],
      ['vertexCount', 'initial_vertex_count'],
      ['universe1867_initial', 'initial_vertex_count'],
      ['applyRule', 'rule_produces_four_edges'],
      ['findAllMatches', 'self_loops_match'],
      ['universe1867_initial', 'self_loops_match'],
    ];

    // Node colors by kind
    const nodeColors = {
      structure: '#34d399',  // green
      def: '#60a5fa',        // blue
      theorem: '#c084fc',    // purple
      root: '#fbbf24'        // yellow
    };

    let edges = [];

    // Wolfram 3D
    let wScene, wCamera, wRenderer, wControls, wGroup;
    let wSpinning = true;

    // Lean 3D
    let lScene, lCamera, lRenderer, lControls, lGroup;
    let lSpinning = true;

    async function loadData() {
      try {
        const response = await fetch('universe1867_edges.json');
        edges = await response.json();
        initWolfram3D();
      } catch (e) {
        console.error('Failed to load edges:', e);
        document.getElementById('wolfram3d').innerHTML = '<img src="universe1867_3d.png" style="width:100%;height:100%;object-fit:contain;">';
      }
      // Initialize Lean visualizations (don't need hypergraph data)
      initLean2D();
      initLean3D();
    }

    // Force-directed layout for hypergraph
    function forceDirectedLayout(edgeList, iterations = 100) {
      const vertices = new Set();
      edgeList.forEach(e => { vertices.add(e[0]); vertices.add(e[1]); });
      const vertexArray = Array.from(vertices).sort((a,b) => a-b);

      const positions = {};
      vertexArray.forEach(v => {
        positions[v] = [
          (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 10
        ];
      });

      const neighbors = {};
      vertexArray.forEach(v => neighbors[v] = new Set());
      edgeList.forEach(([s, t]) => {
        neighbors[s].add(t);
        neighbors[t].add(s);
      });

      const k = 2.0, repulsion = 50, attraction = 0.1, damping = 0.9;

      for (let iter = 0; iter < iterations; iter++) {
        const forces = {};
        vertexArray.forEach(v => forces[v] = [0, 0, 0]);

        for (let i = 0; i < vertexArray.length; i++) {
          for (let j = i + 1; j < vertexArray.length; j++) {
            const v1 = vertexArray[i], v2 = vertexArray[j];
            const p1 = positions[v1], p2 = positions[v2];
            const dx = p1[0] - p2[0], dy = p1[1] - p2[1], dz = p1[2] - p2[2];
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.01;
            const force = repulsion / (dist * dist);
            const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
            forces[v1][0] += fx; forces[v1][1] += fy; forces[v1][2] += fz;
            forces[v2][0] -= fx; forces[v2][1] -= fy; forces[v2][2] -= fz;
          }
        }

        edgeList.forEach(([s, t]) => {
          const p1 = positions[s], p2 = positions[t];
          const dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2];
          const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.01;
          const force = attraction * (dist - k);
          const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
          forces[s][0] += fx; forces[s][1] += fy; forces[s][2] += fz;
          forces[t][0] -= fx; forces[t][1] -= fy; forces[t][2] -= fz;
        });

        const temp = 1 - iter / iterations;
        vertexArray.forEach(v => {
          positions[v][0] += forces[v][0] * temp * damping;
          positions[v][1] += forces[v][1] * temp * damping;
          positions[v][2] += forces[v][2] * temp * damping;
        });
      }

      let cx = 0, cy = 0, cz = 0;
      vertexArray.forEach(v => { cx += positions[v][0]; cy += positions[v][1]; cz += positions[v][2]; });
      cx /= vertexArray.length; cy /= vertexArray.length; cz /= vertexArray.length;

      let maxDist = 0;
      vertexArray.forEach(v => {
        positions[v][0] -= cx; positions[v][1] -= cy; positions[v][2] -= cz;
        const d = Math.sqrt(positions[v][0]**2 + positions[v][1]**2 + positions[v][2]**2);
        if (d > maxDist) maxDist = d;
      });

      const scale = 5 / maxDist;
      vertexArray.forEach(v => {
        positions[v][0] *= scale;
        positions[v][1] *= scale;
        positions[v][2] *= scale;
      });

      return { positions, vertexArray };
    }

    // Force-directed layout for proof graph
    function proofGraphLayout(nodes, edges, iterations = 150) {
      const positions = {};
      const idToIdx = {};
      nodes.forEach((n, i) => {
        idToIdx[n.id] = i;
        // Initial layout: spread by kind (top to bottom: struct -> def -> theorem)
        let yBase = 0;
        if (n.kind === 'structure') yBase = 4;
        else if (n.kind === 'def') yBase = 0;
        else if (n.kind === 'theorem') yBase = -4;
        positions[n.id] = [
          (Math.random() - 0.5) * 8,
          yBase + (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 8
        ];
      });

      const k = 2.5, repulsion = 80, attraction = 0.08, damping = 0.85;

      for (let iter = 0; iter < iterations; iter++) {
        const forces = {};
        nodes.forEach(n => forces[n.id] = [0, 0, 0]);

        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const n1 = nodes[i].id, n2 = nodes[j].id;
            const p1 = positions[n1], p2 = positions[n2];
            const dx = p1[0] - p2[0], dy = p1[1] - p2[1], dz = p1[2] - p2[2];
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.01;
            const force = repulsion / (dist * dist);
            const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
            forces[n1][0] += fx; forces[n1][1] += fy; forces[n1][2] += fz;
            forces[n2][0] -= fx; forces[n2][1] -= fy; forces[n2][2] -= fz;
          }
        }

        // Attraction along edges
        edges.forEach(([s, t]) => {
          if (!positions[s] || !positions[t]) return;
          const p1 = positions[s], p2 = positions[t];
          const dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2];
          const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.01;
          const force = attraction * (dist - k);
          const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
          forces[s][0] += fx; forces[s][1] += fy; forces[s][2] += fz;
          forces[t][0] -= fx; forces[t][1] -= fy; forces[t][2] -= fz;
        });

        const temp = 1 - iter / iterations;
        nodes.forEach(n => {
          positions[n.id][0] += forces[n.id][0] * temp * damping;
          positions[n.id][1] += forces[n.id][1] * temp * damping;
          positions[n.id][2] += forces[n.id][2] * temp * damping;
        });
      }

      // Center and scale
      let cx = 0, cy = 0, cz = 0;
      nodes.forEach(n => { cx += positions[n.id][0]; cy += positions[n.id][1]; cz += positions[n.id][2]; });
      cx /= nodes.length; cy /= nodes.length; cz /= nodes.length;

      let maxDist = 0;
      nodes.forEach(n => {
        positions[n.id][0] -= cx; positions[n.id][1] -= cy; positions[n.id][2] -= cz;
        const d = Math.sqrt(positions[n.id][0]**2 + positions[n.id][1]**2 + positions[n.id][2]**2);
        if (d > maxDist) maxDist = d;
      });

      const scale = 5 / (maxDist || 1);
      nodes.forEach(n => {
        positions[n.id][0] *= scale;
        positions[n.id][1] *= scale;
        positions[n.id][2] *= scale;
      });

      return positions;
    }

    // WOLFRAM 3D
    function initWolfram3D() {
      const container = document.getElementById('wolfram3d');
      const width = container.clientWidth;
      const height = container.clientHeight || 400;

      wScene = new THREE.Scene();
      wScene.background = new THREE.Color(0x050505);

      wCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      wCamera.position.set(12, 9, 12);

      wRenderer = new THREE.WebGLRenderer({ antialias: true });
      wRenderer.setSize(width, height);
      wRenderer.setPixelRatio(window.devicePixelRatio);
      container.insertBefore(wRenderer.domElement, container.firstChild);

      wControls = new THREE.OrbitControls(wCamera, wRenderer.domElement);
      wControls.enableDamping = true;
      wControls.dampingFactor = 0.05;

      wScene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const wDir = new THREE.DirectionalLight(0xffffff, 0.8);
      wDir.position.set(5, 10, 7);
      wScene.add(wDir);

      createWolframGraph();
      animateWolfram();

      window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight || 400;
        wCamera.aspect = w / h;
        wCamera.updateProjectionMatrix();
        wRenderer.setSize(w, h);
      });
    }

    function createWolframGraph() {
      wGroup = new THREE.Group();
      const { positions, vertexArray } = forceDirectedLayout(edges, 150);

      edges.forEach(([src, tgt]) => {
        const p1 = positions[src], p2 = positions[tgt];
        if (p1 && p2) {
          const path = new THREE.LineCurve3(
            new THREE.Vector3(...p1),
            new THREE.Vector3(...p2)
          );
          const tube = new THREE.TubeGeometry(path, 1, 0.025, 6, false);
          const mat = new THREE.MeshPhongMaterial({
            color: 0xff6633,
            transparent: true,
            opacity: 0.7
          });
          wGroup.add(new THREE.Mesh(tube, mat));
        }
      });

      vertexArray.forEach(v => {
        const pos = positions[v];
        const geom = new THREE.SphereGeometry(0.15, 16, 16);
        const mat = new THREE.MeshPhongMaterial({ color: 0x00cccc, shininess: 50 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(...pos);
        wGroup.add(mesh);
      });

      wScene.add(wGroup);
    }

    function resetWolfram3D() {
      wCamera.position.set(12, 9, 12);
      wControls.target.set(0, 0, 0);
      wControls.update();
    }

    function toggleWolframSpin() {
      wSpinning = !wSpinning;
      document.getElementById('spinWolframBtn').classList.toggle('active', wSpinning);
    }

    function animateWolfram() {
      requestAnimationFrame(animateWolfram);
      if (wSpinning && wGroup) wGroup.rotation.y += 0.004;
      wControls.update();
      wRenderer.render(wScene, wCamera);
    }

    // LEAN 2D Canvas
    function initLean2D() {
      const canvas = document.getElementById('lean2d');
      const ctx = canvas.getContext('2d');
      const container = canvas.parentElement;

      // Set canvas size
      canvas.width = container.clientWidth || 400;
      canvas.height = container.clientHeight || 380;

      const positions = proofGraphLayout(proofNodes, proofEdges, 200);

      // Convert 3D to 2D (use x and y, ignore z for 2D view)
      const positions2D = {};
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      proofNodes.forEach(n => {
        const [x, y, z] = positions[n.id];
        positions2D[n.id] = [x, y];
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      });

      // Scale to canvas
      const padding = 60;
      const scaleX = (canvas.width - 2 * padding) / (maxX - minX || 1);
      const scaleY = (canvas.height - 2 * padding) / (maxY - minY || 1);
      const scale = Math.min(scaleX, scaleY);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      function toCanvas(id) {
        const [x, y] = positions2D[id];
        return [
          centerX + x * scale,
          centerY - y * scale  // Flip Y so structures at top
        ];
      }

      // Clear
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      proofEdges.forEach(([s, t]) => {
        const [x1, y1] = toCanvas(s);
        const [x2, y2] = toCanvas(t);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      });

      // Draw nodes
      proofNodes.forEach(n => {
        const [x, y] = toCanvas(n.id);
        const color = nodeColors[n.kind];

        // Node circle
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#ffffff';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(n.label, x, y + 16);
      });

      // Handle resize
      window.addEventListener('resize', () => {
        canvas.width = container.clientWidth || 400;
        canvas.height = container.clientHeight || 380;
        initLean2D();  // Redraw
      });
    }

    // LEAN 3D
    function initLean3D() {
      const container = document.getElementById('lean3d');
      const width = container.clientWidth;
      const height = container.clientHeight || 400;

      lScene = new THREE.Scene();
      lScene.background = new THREE.Color(0x050510);

      lCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      lCamera.position.set(12, 9, 12);

      lRenderer = new THREE.WebGLRenderer({ antialias: true });
      lRenderer.setSize(width, height);
      lRenderer.setPixelRatio(window.devicePixelRatio);
      container.insertBefore(lRenderer.domElement, container.firstChild);

      lControls = new THREE.OrbitControls(lCamera, lRenderer.domElement);
      lControls.enableDamping = true;
      lControls.dampingFactor = 0.05;

      lScene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const lDir = new THREE.DirectionalLight(0xffffff, 0.8);
      lDir.position.set(5, 10, 7);
      lScene.add(lDir);

      createLeanProofGraph();
      animateLean();

      window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight || 400;
        lCamera.aspect = w / h;
        lCamera.updateProjectionMatrix();
        lRenderer.setSize(w, h);
      });
    }

    function createLeanProofGraph() {
      lGroup = new THREE.Group();

      const positions = proofGraphLayout(proofNodes, proofEdges, 200);

      // Edges (white lines)
      proofEdges.forEach(([s, t]) => {
        const p1 = positions[s], p2 = positions[t];
        if (p1 && p2) {
          const path = new THREE.LineCurve3(
            new THREE.Vector3(...p1),
            new THREE.Vector3(...p2)
          );
          const tube = new THREE.TubeGeometry(path, 1, 0.02, 6, false);
          const mat = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
          });
          lGroup.add(new THREE.Mesh(tube, mat));
        }
      });

      // Nodes (colored spheres by kind)
      proofNodes.forEach(n => {
        const pos = positions[n.id];
        const color = new THREE.Color(nodeColors[n.kind]);
        const geom = new THREE.SphereGeometry(0.2, 16, 16);
        const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 50 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(...pos);
        lGroup.add(mesh);
      });

      lScene.add(lGroup);
    }

    function resetLean3D() {
      lCamera.position.set(12, 9, 12);
      lControls.target.set(0, 0, 0);
      lControls.update();
    }

    function toggleLeanSpin() {
      lSpinning = !lSpinning;
      document.getElementById('spinLeanBtn').classList.toggle('active', lSpinning);
    }

    function animateLean() {
      requestAnimationFrame(animateLean);
      if (lSpinning && lGroup) lGroup.rotation.y += 0.004;
      lControls.update();
      lRenderer.render(lScene, lCamera);
    }

    window.addEventListener('load', loadData);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Proof Map - Wolfram-Lean Bridge</title>
  <script src="wolfram_proofs_data.js"></script>
  <style>
    :root {
      --bg: #000000;
      --card: #0a0a0a;
      --border: rgba(255,255,255,0.1);
      --text: #fafafa;
      --dim: #9ca3af;
      --accent: #60a5fa;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      min-height: 100vh;
      overflow: hidden;
    }
    /* Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 24px;
      background: rgba(0,0,0,0.9);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
    }
    .header h1 {
      font-size: 16px;
      font-weight: 600;
    }
    .header h1 span {
      color: var(--accent);
    }
    /* Search */
    .search-box {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .search-box input {
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      color: var(--text);
      font-size: 13px;
      width: 240px;
    }
    .search-box input:focus {
      outline: none;
      border-color: var(--accent);
    }
    /* Canvas */
    #canvas {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
    }
    /* Legend */
    .legend {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 11px;
      z-index: 100;
    }
    .legend h3 {
      font-size: 10px;
      color: var(--dim);
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      opacity: 1;
      transition: opacity 0.2s;
    }
    .legend-item.filtered {
      opacity: 0.3;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }
    /* Tooltip */
    .tooltip {
      position: fixed;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 300px;
      z-index: 200;
    }
    .tooltip.visible {
      opacity: 1;
    }
    .tooltip h4 {
      font-size: 13px;
      margin-bottom: 6px;
    }
    .tooltip .kind {
      display: inline-block;
      padding: 2px 6px;
      background: var(--accent);
      border-radius: 3px;
      font-size: 10px;
      margin-bottom: 6px;
    }
    .tooltip .family {
      color: var(--dim);
      font-size: 11px;
    }
    /* Controls */
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }
    .controls button {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .controls button:hover {
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Wolfram-Lean Bridge <span>2D Proof Map</span></h1>
    <div class="search-box">
      <input type="text" id="search" placeholder="Search declarations...">
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="legend" id="legend"></div>

  <div class="tooltip" id="tooltip">
    <h4 id="tooltip-name"></h4>
    <span class="kind" id="tooltip-kind"></span>
    <div class="family" id="tooltip-family"></div>
  </div>

  <div class="controls">
    <button onclick="resetView()">Reset View</button>
    <button onclick="zoomIn()">+</button>
    <button onclick="zoomOut()">-</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    let width, height;
    let scale = 1;
    let offsetX = 0, offsetY = 0;
    let isDragging = false;
    let dragStartX, dragStartY;
    let hoveredNode = null;
    let filterFamily = null;
    let searchTerm = '';

    const nodeRadius = 12;
    const items = wolframProofsData.items;
    const edges = wolframProofsData.edges;

    // Colors
    const colors = {
      'Core': '#ef4444',
      'Constructor': '#8b5cf6',
      'QKD/BB84': '#f59e0b'
    };

    // Build legend
    const legendEl = document.getElementById('legend');
    legendEl.innerHTML = '<h3>Families</h3>';
    Object.entries(colors).forEach(([family, color]) => {
      const div = document.createElement('div');
      div.className = 'legend-item';
      div.innerHTML = `<div class="legend-color" style="background: ${color};"></div> ${family}`;
      div.onclick = () => toggleFilter(family);
      legendEl.appendChild(div);
    });

    function toggleFilter(family) {
      if (filterFamily === family) {
        filterFamily = null;
        document.querySelectorAll('.legend-item').forEach(el => el.classList.remove('filtered'));
      } else {
        filterFamily = family;
        document.querySelectorAll('.legend-item').forEach((el, i) => {
          el.classList.toggle('filtered', Object.keys(colors)[i] !== family);
        });
      }
      draw();
    }

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight - 60;
      canvas.width = width * window.devicePixelRatio;
      canvas.height = height * window.devicePixelRatio;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      draw();
    }

    function toScreen(x, y) {
      return {
        x: width / 2 + (x - 0.5) * width * 0.8 * scale + offsetX,
        y: height / 2 + (y - 0.5) * height * 0.8 * scale + offsetY
      };
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);

      // Draw edges
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      edges.forEach(([from, to]) => {
        const fromNode = items[from];
        const toNode = items[to];
        if (filterFamily && fromNode.family !== filterFamily && toNode.family !== filterFamily) return;
        const p1 = toScreen(fromNode.pos.x, fromNode.pos.y);
        const p2 = toScreen(toNode.pos.x, toNode.pos.y);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      });

      // Draw nodes
      items.forEach((item, i) => {
        if (filterFamily && item.family !== filterFamily) return;
        if (searchTerm && !item.name.toLowerCase().includes(searchTerm)) return;

        const pos = toScreen(item.pos.x, item.pos.y);
        const color = colors[item.family] || '#666';
        const r = item.kind === 'theorem' ? nodeRadius * 1.4 : nodeRadius;

        ctx.beginPath();
        if (item.kind === 'theorem') {
          // Hexagon for theorems
          for (let j = 0; j < 6; j++) {
            const angle = (j * Math.PI) / 3 - Math.PI / 6;
            const x = pos.x + r * Math.cos(angle);
            const y = pos.y + r * Math.sin(angle);
            if (j === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
        } else {
          ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
        }

        ctx.fillStyle = color;
        ctx.fill();

        if (hoveredNode === i) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });

      // Labels for hovered node
      if (hoveredNode !== null) {
        const item = items[hoveredNode];
        const pos = toScreen(item.pos.x, item.pos.y);
        ctx.fillStyle = '#fff';
        ctx.font = '11px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(item.name, pos.x, pos.y - nodeRadius - 8);
      }
    }

    function findNodeAt(x, y) {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (filterFamily && item.family !== filterFamily) continue;
        if (searchTerm && !item.name.toLowerCase().includes(searchTerm)) continue;

        const pos = toScreen(item.pos.x, item.pos.y);
        const r = item.kind === 'theorem' ? nodeRadius * 1.4 : nodeRadius;
        const dx = x - pos.x;
        const dy = y - pos.y;
        if (dx * dx + dy * dy < r * r) return i;
      }
      return null;
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (isDragging) {
        offsetX += e.clientX - dragStartX;
        offsetY += e.clientY - dragStartY;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        draw();
        return;
      }

      const node = findNodeAt(x, y);
      if (node !== hoveredNode) {
        hoveredNode = node;
        draw();

        if (node !== null) {
          const item = items[node];
          document.getElementById('tooltip-name').textContent = item.name;
          document.getElementById('tooltip-kind').textContent = item.kind;
          document.getElementById('tooltip-family').textContent = item.family;
          tooltip.style.left = (e.clientX + 15) + 'px';
          tooltip.style.top = (e.clientY + 15) + 'px';
          tooltip.classList.add('visible');
        } else {
          tooltip.classList.remove('visible');
        }
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      hoveredNode = null;
      tooltip.classList.remove('visible');
      draw();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      scale *= factor;
      scale = Math.max(0.5, Math.min(3, scale));
      draw();
    });

    document.getElementById('search').addEventListener('input', (e) => {
      searchTerm = e.target.value.toLowerCase();
      draw();
    });

    function resetView() {
      scale = 1;
      offsetX = 0;
      offsetY = 0;
      draw();
    }

    function zoomIn() {
      scale *= 1.2;
      scale = Math.min(3, scale);
      draw();
    }

    function zoomOut() {
      scale *= 0.8;
      scale = Math.max(0.5, scale);
      draw();
    }

    window.addEventListener('resize', resize);
    resize();
  </script>
</body>
</html>

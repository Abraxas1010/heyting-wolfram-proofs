<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Proof Visualization</title>
  <style>
    :root {
      --bg: #000000;
      --card: #0a0a0a;
      --border: rgba(255,255,255,0.1);
      --text: #fafafa;
      --dim: #9ca3af;
      --accent: #60a5fa;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      min-height: 100vh;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas { display: block; }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
      display: flex;
      align-items: center;
      gap: 20px;
      z-index: 100;
    }
    .overlay h1 {
      font-size: 18px;
      font-weight: 600;
    }
    .overlay h1 span { color: var(--accent); }
    .tabs {
      display: flex;
      gap: 8px;
    }
    .tab {
      padding: 6px 14px;
      background: rgba(255,255,255,0.1);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--dim);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    .tab:hover {
      border-color: var(--accent);
      color: var(--text);
    }
    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
    }
    .info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.85);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      max-width: 280px;
      z-index: 100;
    }
    .info h3 {
      font-size: 13px;
      margin-bottom: 8px;
      color: var(--accent);
    }
    .info p {
      font-size: 11px;
      color: var(--dim);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .legend {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 4px 8px;
      font-size: 10px;
    }
    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }
    .btn {
      padding: 8px 14px;
      background: rgba(0,0,0,0.7);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-size: 11px;
    }
    .btn:hover {
      background: rgba(96,165,250,0.3);
      border-color: var(--accent);
    }
    .back-link {
      position: absolute;
      top: 16px;
      right: 20px;
      color: var(--dim);
      font-size: 11px;
      text-decoration: none;
      z-index: 100;
    }
    .back-link:hover { color: var(--accent); }

    /* Node detail panel */
    .detail-panel {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0,0,0,0.92);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 16px;
      max-width: 320px;
      z-index: 200;
      display: none;
    }
    .detail-panel.visible {
      display: block;
    }
    .detail-panel .close-btn {
      position: absolute;
      top: 8px;
      right: 10px;
      background: none;
      border: none;
      color: var(--dim);
      cursor: pointer;
      font-size: 16px;
    }
    .detail-panel .close-btn:hover { color: var(--text); }
    .detail-panel h4 {
      font-size: 14px;
      color: var(--accent);
      margin-bottom: 12px;
      padding-right: 20px;
    }
    .detail-row {
      display: flex;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .detail-row .label {
      color: var(--dim);
      width: 70px;
      flex-shrink: 0;
    }
    .detail-row .value {
      color: var(--text);
      word-break: break-word;
    }
    .detail-row .value.kind {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
    }
    .hint {
      font-size: 10px;
      color: var(--dim);
      margin-top: 6px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="overlay">
    <h1>3D Proof <span>Visualization</span></h1>
    <div class="tabs">
      <button class="tab active" onclick="showView('hypergraph')">Hypergraph</button>
      <button class="tab" onclick="showView('dag')">Proof DAG</button>
    </div>
  </div>

  <a href="index.html" class="back-link">← Back to Visualizations</a>

  <div class="info">
    <h3 id="view-title">Hypergraph View</h3>
    <p id="view-desc">3D hypergraph showing proof term structure. Colored lines show hyperedge connections between premises and conclusions.</p>
    <div class="legend">
      <div class="legend-color" style="background: #66ccff"></div><span>Lambda (λ)</span>
      <div class="legend-color" style="background: #b266ff"></div><span>Application</span>
      <div class="legend-color" style="background: #ff9933"></div><span>Constant</span>
      <div class="legend-color" style="background: #66ff80"></div><span>Bound Var</span>
      <div class="legend-color" style="background: #808080"></div><span>Metadata</span>
    </div>
    <p class="hint">Click on a node to see details</p>
  </div>

  <div class="controls">
    <button class="btn" onclick="resetCamera()">Reset View</button>
    <button class="btn" onclick="toggleSpin()">Toggle Spin</button>
  </div>

  <!-- Detail panel for clicked nodes -->
  <div class="detail-panel" id="detail-panel">
    <button class="close-btn" onclick="hideDetail()">&times;</button>
    <h4 id="detail-title">Node Details</h4>
    <div class="detail-row">
      <span class="label">ID:</span>
      <span class="value" id="detail-id"></span>
    </div>
    <div class="detail-row">
      <span class="label">Kind:</span>
      <span class="value kind" id="detail-kind"></span>
    </div>
    <div class="detail-row">
      <span class="label">Label:</span>
      <span class="value" id="detail-label"></span>
    </div>
    <div class="detail-row">
      <span class="label">Children:</span>
      <span class="value" id="detail-children"></span>
    </div>
    <div class="detail-row">
      <span class="label">Parent of:</span>
      <span class="value" id="detail-parent"></span>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Proof term data from HeytingLean.Crypto.QKD.BB84.copyAll_impossible
    const proofData = {
      nodes: [
        {id: 0, kind: "lam", label: "λ h"},
        {id: 1, kind: "app", label: "app"},
        {id: 2, kind: "app", label: "app"},
        {id: 3, kind: "app", label: "app"},
        {id: 4, kind: "const", label: "TaskCT.possible"},
        {id: 5, kind: "const", label: "BB84Substrate"},
        {id: 6, kind: "const", label: "bb84TaskCT"},
        {id: 7, kind: "const", label: "copyAll"},
        {id: 8, kind: "app", label: "app"},
        {id: 9, kind: "app", label: "app"},
        {id: 10, kind: "app", label: "app"},
        {id: 11, kind: "const", label: "match_1_1"},
        {id: 12, kind: "lam", label: "λ h"},
        {id: 13, kind: "app", label: "app"},
        {id: 14, kind: "app", label: "app"},
        {id: 15, kind: "app", label: "app"},
        {id: 16, kind: "const", label: "TaskCT.possible"},
        {id: 17, kind: "const", label: "BB84Substrate"},
        {id: 18, kind: "const", label: "bb84TaskCT"},
        {id: 19, kind: "const", label: "copyAll"},
        {id: 20, kind: "mdata", label: "mdata"},
        {id: 21, kind: "const", label: "False"},
        {id: 22, kind: "bvar", label: "bvar"},
        {id: 23, kind: "lam", label: "λ c"},
        {id: 24, kind: "app", label: "app"},
        {id: 25, kind: "app", label: "app"},
        {id: 26, kind: "const", label: "TaskCT.Ctor"},
        {id: 27, kind: "const", label: "BB84Substrate"},
        {id: 28, kind: "const", label: "bb84TaskCT"},
        {id: 29, kind: "lam", label: "λ hc"},
        {id: 30, kind: "app", label: "app"},
        {id: 31, kind: "app", label: "app"},
        {id: 32, kind: "app", label: "app"},
        {id: 33, kind: "app", label: "app"},
        {id: 34, kind: "const", label: "TaskCT.implements"},
        {id: 35, kind: "const", label: "BB84Substrate"},
        {id: 36, kind: "const", label: "bb84TaskCT"},
        {id: 37, kind: "bvar", label: "bvar"},
        {id: 38, kind: "const", label: "copyAll"},
        {id: 39, kind: "app", label: "app"},
        {id: 40, kind: "app", label: "app"},
        {id: 41, kind: "const", label: "not_implements_copyAll"},
        {id: 42, kind: "bvar", label: "bvar"},
        {id: 43, kind: "bvar", label: "bvar"}
      ],
      // Hyperedges: [children..., parent]
      hyperedges: [
        [1, 8, 0], [2, 7, 1], [3, 6, 2], [4, 5, 3], [9, 23, 8],
        [10, 22, 9], [11, 12, 10], [13, 20, 12], [14, 19, 13],
        [15, 18, 14], [16, 17, 15], [21, 20], [24, 29, 23],
        [25, 28, 24], [26, 27, 25], [30, 39, 29], [31, 38, 30],
        [32, 37, 31], [33, 36, 32], [34, 35, 33], [40, 43, 39],
        [41, 42, 40]
      ]
    };

    // Build lookup maps for node relationships
    const nodeChildren = {};  // nodeId -> array of child node IDs
    const nodeParents = {};   // nodeId -> array of edges where this node is parent
    proofData.nodes.forEach(n => {
      nodeChildren[n.id] = [];
      nodeParents[n.id] = [];
    });
    proofData.hyperedges.forEach(edge => {
      const parent = edge[edge.length - 1];
      const children = edge.slice(0, -1);
      nodeChildren[parent] = children;
      children.forEach(c => nodeParents[c].push(parent));
    });

    // Colors by node kind
    const kindColors = {
      lam: 0x66ccff,
      app: 0xb266ff,
      const: 0xff9933,
      bvar: 0x66ff80,
      fvar: 0x80ff80,
      forall: 0xff6699,
      mdata: 0x808080,
      sort: 0xffff66,
      let: 0x99ccff,
      proj: 0xcc9966
    };

    const kindColorCSS = {
      lam: '#66ccff',
      app: '#b266ff',
      const: '#ff9933',
      bvar: '#66ff80',
      fvar: '#80ff80',
      forall: '#ff6699',
      mdata: '#808080',
      sort: '#ffff66',
      let: '#99ccff',
      proj: '#cc9966'
    };

    const kindNames = {
      lam: 'Lambda',
      app: 'Application',
      const: 'Constant',
      bvar: 'Bound Variable',
      fvar: 'Free Variable',
      forall: 'Forall',
      mdata: 'Metadata',
      sort: 'Sort',
      let: 'Let',
      proj: 'Projection'
    };

    let scene, camera, renderer, controls;
    let hypergraphGroup, dagGroup;
    let currentView = 'hypergraph';
    let spinning = false;
    let nodeMeshes = [];  // For raycasting
    let positions = { hypergraph: [], dag: [] };

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function init() {
      const container = document.getElementById('container');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050505);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 4, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(5, 10, 7);
      scene.add(directional);

      // Create both views
      createHypergraphView();
      createDAGView();

      // Start with hypergraph
      showView('hypergraph');

      // Event listeners
      window.addEventListener('resize', onResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      animate();
    }

    function createHypergraphView() {
      hypergraphGroup = new THREE.Group();

      // Layout nodes using force-directed style
      positions.hypergraph = layoutNodes(proofData.nodes.length, 'spring');

      // Rainbow colors for hyperedges
      const numEdges = proofData.hyperedges.length;

      // Draw hyperedges as colored lines (cleaner than filled polygons)
      proofData.hyperedges.forEach((edge, i) => {
        const hue = i / numEdges;
        const color = new THREE.Color().setHSL(hue, 0.9, 0.55);
        const parentIdx = edge[edge.length - 1];

        // Draw lines from each child to parent
        edge.slice(0, -1).forEach(childIdx => {
          const points = [
            new THREE.Vector3(...positions.hypergraph[childIdx]),
            new THREE.Vector3(...positions.hypergraph[parentIdx])
          ];

          // Create tube for thicker visible lines
          const path = new THREE.CatmullRomCurve3(points);
          const tubeGeom = new THREE.TubeGeometry(path, 8, 0.025, 8, false);
          const tubeMat = new THREE.MeshPhongMaterial({
            color: color,
            transparent: true,
            opacity: 0.7,
            shininess: 50
          });
          hypergraphGroup.add(new THREE.Mesh(tubeGeom, tubeMat));
        });
      });

      // Draw nodes as spheres
      proofData.nodes.forEach((node, i) => {
        const color = kindColors[node.kind] || 0xffffff;
        const geom = new THREE.SphereGeometry(0.15, 20, 20);
        const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 40 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(...positions.hypergraph[i]);
        mesh.userData = { nodeIndex: i, view: 'hypergraph' };
        hypergraphGroup.add(mesh);
        nodeMeshes.push(mesh);
      });

      scene.add(hypergraphGroup);
    }

    function createDAGView() {
      dagGroup = new THREE.Group();

      // Layout nodes using layered embedding
      positions.dag = layoutNodes(proofData.nodes.length, 'layered');

      // Draw directed edges with arrows
      proofData.hyperedges.forEach(edge => {
        const parentIdx = edge[edge.length - 1];
        edge.slice(0, -1).forEach(childIdx => {
          const start = new THREE.Vector3(...positions.dag[childIdx]);
          const end = new THREE.Vector3(...positions.dag[parentIdx]);

          // Tube for edge
          const path = new THREE.LineCurve3(start, end);
          const tubeGeom = new THREE.TubeGeometry(path, 1, 0.025, 8, false);
          const tubeMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
          dagGroup.add(new THREE.Mesh(tubeGeom, tubeMat));

          // Arrow cone
          const dir = end.clone().sub(start).normalize();
          const arrowPos = end.clone().sub(dir.clone().multiplyScalar(0.22));
          const coneGeom = new THREE.ConeGeometry(0.07, 0.14, 8);
          const coneMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
          const cone = new THREE.Mesh(coneGeom, coneMat);
          cone.position.copy(arrowPos);
          cone.lookAt(end);
          cone.rotateX(Math.PI / 2);
          dagGroup.add(cone);
        });
      });

      // Draw nodes as colored spheres
      proofData.nodes.forEach((node, i) => {
        const color = kindColors[node.kind] || 0xffffff;
        const geom = new THREE.SphereGeometry(0.18, 20, 20);
        const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 30 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(...positions.dag[i]);
        mesh.userData = { nodeIndex: i, view: 'dag' };
        dagGroup.add(mesh);
        nodeMeshes.push(mesh);
      });

      dagGroup.visible = false;
      scene.add(dagGroup);
    }

    function layoutNodes(count, type) {
      const pos = [];
      if (type === 'spring') {
        // Spherical spring layout
        for (let i = 0; i < count; i++) {
          const phi = Math.acos(-1 + (2 * i) / count);
          const theta = Math.sqrt(count * Math.PI) * phi;
          const r = 3;
          pos.push([
            r * Math.cos(theta) * Math.sin(phi),
            r * Math.sin(theta) * Math.sin(phi),
            r * Math.cos(phi)
          ]);
        }
      } else {
        // Layered layout for DAG
        for (let i = 0; i < count; i++) {
          const layer = Math.floor(i / 6);
          const inLayer = i % 6;
          const x = (inLayer - 2.5) * 1.3;
          const y = -layer * 1.1;
          const z = Math.sin(i * 0.4) * 0.4;
          pos.push([x, y, z]);
        }
      }
      return pos;
    }

    function showView(view) {
      currentView = view;
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.tab:nth-child(${view === 'hypergraph' ? 1 : 2})`).classList.add('active');

      hypergraphGroup.visible = (view === 'hypergraph');
      dagGroup.visible = (view === 'dag');

      if (view === 'hypergraph') {
        document.getElementById('view-title').textContent = 'Hypergraph View';
        document.getElementById('view-desc').textContent = '3D hypergraph showing proof term structure. Colored lines show hyperedge connections between premises and conclusions.';
      } else {
        document.getElementById('view-title').textContent = 'Proof DAG View';
        document.getElementById('view-desc').textContent = 'Layered directed graph showing proof structure. Arrows flow from premises to parent nodes.';
      }

      hideDetail();
    }

    function onMouseClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Only check nodes in current view
      const visibleNodes = nodeMeshes.filter(m => m.userData.view === currentView);
      const intersects = raycaster.intersectObjects(visibleNodes);

      if (intersects.length > 0) {
        const nodeIndex = intersects[0].object.userData.nodeIndex;
        showNodeDetail(nodeIndex);
      }
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const visibleNodes = nodeMeshes.filter(m => m.userData.view === currentView);
      const intersects = raycaster.intersectObjects(visibleNodes);

      renderer.domElement.style.cursor = intersects.length > 0 ? 'pointer' : 'grab';
    }

    function showNodeDetail(nodeIndex) {
      const node = proofData.nodes[nodeIndex];
      const panel = document.getElementById('detail-panel');

      document.getElementById('detail-title').textContent = node.label || `Node ${node.id}`;
      document.getElementById('detail-id').textContent = node.id;

      const kindEl = document.getElementById('detail-kind');
      kindEl.textContent = kindNames[node.kind] || node.kind;
      kindEl.style.background = kindColorCSS[node.kind] || '#666';
      kindEl.style.color = ['bvar', 'fvar', 'sort'].includes(node.kind) ? '#000' : '#fff';

      document.getElementById('detail-label').textContent = node.label;

      const children = nodeChildren[node.id] || [];
      document.getElementById('detail-children').textContent = children.length > 0
        ? children.map(c => proofData.nodes[c].label).join(', ')
        : '(none)';

      const parents = nodeParents[node.id] || [];
      document.getElementById('detail-parent').textContent = parents.length > 0
        ? parents.map(p => proofData.nodes[p].label).join(', ')
        : '(root or leaf)';

      panel.classList.add('visible');
    }

    function hideDetail() {
      document.getElementById('detail-panel').classList.remove('visible');
    }

    function resetCamera() {
      camera.position.set(5, 4, 6);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    function toggleSpin() {
      spinning = !spinning;
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      if (spinning) {
        const group = currentView === 'hypergraph' ? hypergraphGroup : dagGroup;
        group.rotation.y += 0.005;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
